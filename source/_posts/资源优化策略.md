---
title: 资源优化策略
date: 2017-12-14 13:48:44
tags: http
---

# 资源优化策略

对于请求、部署资源的一些优化策略,这是一个非常容易被忽视的领域,这里总结一下前辈们的实践经验,希望有所帮助

本文解决的问题：
- 资源更新流程的优化
- http请求优化：什么情况使用304与缓存
- http缓存策略
- 什么是cdn

<!-- more -->

# 资源更新流程的优化

首先，我们从最简单的一个网页开始：

- 新建一个index.html和样式文件a.css，放到服务器，在本地直接预览即可。让我们来查看下资源请求
![img](optimize_1.png)
200，说明获取到了资源文件，但是还没有完...

对于用户访问量大的网页来说，200远远不够，就拿a.css说吧，试想下用户每次进入该页面都需要花费时间去请求a.css资源，体验很不好还浪费宽带，所以我们希望可以这样优化：
![img](optimize_2.png)
利用304来使用本地缓存，但还是没有完...

304请求叫做协商缓存，还是会跟服务器进行通信，来判断本地缓存是否更新，所以我们有这样的优化方法：
![img](optimize_3.png)
直接利用200缓存，不跟服务器进行通信，看起来挺不错。但是！我们都没有跟服务器进行通信了，那服务器的文件内容更新了的话，我们怎么知道需要更新缓存文件呢？

对的，我们可以更新html页面的引用路径来告诉浏览器主动放弃缓存，加载新的资源：
![img](optimize_4.png)
这样，当文件更新时，浏览器就会去请求新的资源，放弃旧的缓存了。但是这里面又有门道了，像这样：
![img](optimize_5.png)
html引用了3个css文件，我们只改变了其中一个文件，若是所有的引用都更新的话，浏览器不是会重复加载内容其实未更新的文件？

在这里，我们不难发现解决方法：我们改变了哪个文件，就将这个文件的引用更新即可，这里就需要用到**数据摘要算法**，这样就可以精确的控制文件缓存了。
![img](optimize_6.png)
到这里，你以为就完了吗？NO.NO.NO.太年轻

现在的互联网，为了优化网络请求速度，会静态资源和网页分集群部署，静态资源会被部署到cdn上，所以网页上引用的静态资源对于的部署路径：
![img](optimize_7.png)

好了，现在我要更新资源了，那么，你能告诉我是先更新网页，还是更新静态资源吗？怎么样才能平滑升级呢？

- 如果我们先更新网页的话，在更新的这段时间内，新访问的用户加载的是新页面，并且请求的也是新的静态资源，这会导致页面样式无法显示的问题
- 如果我们先更新静态资源的话，在更新的这段时间内，用户请求的是旧的静态资源，但是cdn上的静态资源已经被新的静态资源覆盖了，会导致同样的问题。

这其中导致的问题，不是我们半夜悄悄更新就可以回避的，大型网站的访问量是不会存在绝对的低峰期，只有相对的。

那么怎么办呢？对了，覆盖！我们只需要采取非覆盖式更新就没问题，先更新静态资源，再更新网页就可以满足我们的需求了。
![img](optimize_8.png)

所以总结以上，一个好的资源优化方案，有以下几点：

- 配置超长时间的本地缓存 —— 节省带宽，提高性能
- 采用内容摘要作为缓存更新依据 —— 精确的缓存控制
- 静态资源CDN部署 —— 优化网络请求
- 更资源发布路径实现非覆盖式发布 —— 平滑升级

## http请求优化：什么情况使用304与缓存

前面说了资源的部署流程和优化，现在说下http请求的优化吧

- http缓存：指的是当web请求到达时，如果本地有未过期的缓存，就直接应用缓存，而不是从服务器提取缓存
- 缓存的种类：1.浏览器本地缓存 2.代理缓存服务器

缓存流程图：
- 第一次请求时(用户第一次打开页面或者ctrl+F5)：
![img](cache_1.jpg)
第一次请求时，所有的文件都是从服务器获取的，本地浏览器是没有缓存的。第一次请求过后就有了缓存，整个过程都会变得不同：

- 再次请求：
![img](cache_2.png)
当服务端的web请求到达时，浏览器会先判断是否有本地缓存，缓存是否过期(max-age + Date标志)，没有过期，那么会直接应用浏览器缓存；若过期了，准备与服务端进行通信，先判断服务端的请求是否有etag标志，有则发送带有if-None-Match标志的请求；没有，则判断服务端的请求是否有last-Modified标志，有则发送带有if-Modified-Since标志的请求；浏览器的请求到达服务端后，会进行对比，若etag === if-None-Modified或者last-Modified <= if-Modified-Since的话，代表服务端的文件没有更新，返回304状态码(协商缓存)告诉浏览器可以继续使用本地的缓存；若更新文件，那么就重新发送资源。
- Last-Modified: 服务端缓存最新的更新时间；
- if-Modified-Since: 上一次请求触发资源更新时，响应头的last-Modified
所以if-Modified-Since < last-Modified，代表服务端缓存不可以使用
- etag: 服务端缓存的标志，
- if-None-Match: 上一次请求触发资源更新时，响应头的etag
所以etag !== if-None-Modified代表服务端缓存不可以使用)

## http缓存策略

- Cache-Control策略
用来指明当前资源的有效期；

Public
任何情况下都得缓存该资源。

Private
指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。缓存只开放给某些特定的用户，比如服务器的用户，其他用户则不能缓存这些数据。

no-cache
指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，容易望文生义~。要求向服务器发起新鲜度检验

no-store
用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。主要用于一些机密文件

max-age
指示客户端该端时间内缓存都是最新的。以秒为单位。比如：Cache-Control：max-age=120 表示2分钟之后过期。(很多未缓存文件是以max-age=0的情况)

- Last-Modified/If-Modified-Since  （Last-Modified/If-Modified-Since要配合Cache-Control使用。）

- Etag/If-None-Match：(Etag/If-None-Match也要配合Cache-Control使用。)

etag优先级大于last-Modified

- 为什么有了last-Modified还要etag?

1、一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET;
 
2、某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的变化时秒为单位的，这种修改无法判断。因此需要Etag来判断。
 
3、某些服务器不能精确的得到文件的最后修改时间；
 
 ## cdn相关
 
 - 什么是cdn？
 cdn也叫内容分发网络，是一个策略性部署的系统，包括分布式存储、内容管理、网络请求重定向、负载均衡4个模块。
 
 - cdn的优点：
 
 1、解决跨域和跨运营商的问题，提高了访问速度；
 2、cdn的分布式存储减轻了源站的负荷；