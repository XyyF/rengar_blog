---
title: 简述RSA算法
date: 2018-09-04 15:19:12
tags: 算法
---

# 简述RSA算法

本文解决的问题：
- RSA算法用到的数论知识
- RSA算法的实现原理
- RSA算法的可靠性

<!-- more -->

灵感来自：[阮一峰的网络日志](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)

## RSA算法用到的数论知识
了解RSA算法原理前，我们需要了解一些简单的数论知识：

### 质数和互质

质数：除了1以外，无法再因式分解的数字；

互质：两个整数，除了1以外就没有公共因子可以提取。

由此，我们可以总结出一些简单互质的规律：

- 若较大的整数是质数，那么互质；
- 若较小的整数是质数，只要较大的整数不是前者的倍数，那么互质；
- 两个整数都是质数，互质；
- 对于一个整数p，p与p-1互质；
- 对于一个奇数p，p与p-2互质；
- 1与任何整数都互质

这里我们不会太高深，只要清楚"若较大的整数是质数，那么互质"就行

### 欧拉函数
欧拉函数，挺熟悉的名称，是计算小于等于正整数n的正整数中与n互质的数的数目，其值记为φ(n)

这里只展示一种特殊情况：
对于两个互质的数p、q
```
n = p * q
```
那么有：
```
φ(n) = φ(p * q) = φ(p) * φ(q) = (p - 1) * (q - 1)
```
这里的证明需要用到[中国剩余定理](https://en.wikipedia.org/wiki/Chinese_remainder_theorem)

### 欧拉定理
如果有两个正整数e、n互质，那么欧拉定理满足：

e<sup>φ(n)</sup> ≡ 1 mod n


### 模反元素
如果有两个正整数e、n互质，那么就一定可以找到一个正整数d，满足：
```
ed ≡ 1 mod n
```
使得ed - 1能被n整除，这时d就是e的模反元素。

至于为什么一定存在模反元素d：

e<sup>φ(n)</sup> = e * e<sup>φ(n) - 1</sup> ≡ 1 mod n

所以e的模反元素就是e<sup>φ(n) - 1</sup>

## RSA算法的实现原理
下面将RSA算法实现分为几个步骤：
1. 选择两个随机的互质的数p和q，一般都是大数，求得两者的积：
n = p * q （n一般是1024位）

2. 求得n的欧拉函数：
φ(n) = φ(p * q) = φ(p) * φ(q) = (p - 1) * (q - 1)

3. 选择随机的整数e，满足：
1 < e < φ(n)，并且e与φ(n)互质。
为什么要

4. 计算出e的模反元素d，根据：
ed ≡ 1 mod φ(n)

5. 将n、e封装为公钥，将n、d封装为私钥，这样，就得到了公钥和私钥

## RSA算法的可靠性
根据公钥和私钥的封装我们知道，要破解私钥，就需要知道d的值

d的值可以由ed ≡ 1 mod φ(n)求得

由φ(n) = (p - 1) * (q - 1)，就需要知道p、q的值

n = p * q，看起来破解p、q的值很简单，迄今为止还没有很好的对极大数因式分解的方法，所以只要你的n位数够长，因式分解够困难，那么破解的难度就越大。

> "对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。