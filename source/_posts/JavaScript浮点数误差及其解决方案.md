---
title: JavaScript浮点数误差及其解决方案
date: 2018-09-04 15:19:12
tags: 浮点数
---

# JavaScript浮点数误差及其解决方案

本文解决的问题：
- 浮点数产生原因
- 衍生问题1：0.1 + 0.2 !== 0.3
- 衍生问题2：为什么value = 0.1，value的值就是0.1
- 衍生问题3：大数危机
- 解决方案

<!-- more -->

## 产生误差的原因 - 浮点数的存储

浮点数的存储实现遵循 IEEE 754 标准，双精确度64位二进制固定长度来表示，这样的优点是可以统一处理整数和小数，节省存储空间。

64位比特又可分为三个部分：
  - 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数
  - 指数位E：中间的 11 位存储指数（exponent），用来表示次方数
  (表示的最大的数：11111111111 = 2<sup>11</sup> - 1 = 2047)
  - 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零

实际数字就可以用以下公式来计算：

V = (-1)<sup>S</sup> * 2<sup>E</sup> * M

但是由于科学计数法中的指数是可以为负数的，像2<sup>-2</sup>。
所以取一个中间数1023(01111111111 = 2<sup>10</sup> - 1)，
[0,1022]表示为负，[1024,2047] 表示为正。

如4.5 的指数E = 1025，尾数M为 001。

最终的公式变成：(二进制中,2<sup>2</sup>相当于将小数点右移扩大2位，参考十进制的计算)

V = (-1)<sup>S</sup> * 2<sup>(E - 2013)</sup> * (1.M)

所以4.5最终表示为（M=001、E=1025）：

0 100000000001 001000000..... = 1 * 2<sup>2</sup> * 1.001 = 100.1 = 4.5

下面再以0.1 例解释浮点误差的原因。0.1的二进制存储：

0 01111111011 1001100110011001100110011001100110011001100110011010，
转化成十进制后为0.100000000000000005551115123126，因此就出现了浮点误差。

## 为什么 0.1+0.2=0.30000000000000004？

## 为什么 value=0.1 能得到 0.1？

因为尾数位固定长度是 52 位，再加上被省略的一位，所以浮点数最多可以考虑的位数是2<sup>53</sup>=9007199254740992，对应科学计数尾数是 9.007199254740992，这也是 JS 最多能表示的精度。

它的长度是 16，所以可以使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理。于是就有：

// 返回，去掉末尾的零后正好为 0.1
0.10000000000000000555.toPrecision(16) = 0.1000000000000000

// 但你看到的0.1实际上并不是实际存储的0.1。用更高的精度：
0.1.toPrecision(21) = 0.100000000000000005551

## 大数危机

###对于尾数位：
如果整数大于9007199254740992(2<sup>53</sup>)，尾数位以无法表示这个数，会发生什么？

所有超过2<sup>53</sup>的数，多出的尾数位都会被省略，最终的值都是2<sup>53</sup>

### 对于指数位：
由于指数位最大值是1024，所以最大可以表示的二进制整数是2<sup>1024</sup>*(1.111111.....)，这就是能表示的最大整数。
但你并不能这样计算这个数字，因为这样的数字变成了Infinity

### 解决方案：
要想解决大数的问题原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生的差很多。

## 解决误差的方案

### toPrecision vs toFixed
数据处理时，这两个函数很容易混淆。它们的共同点是把数字转成字符串供展示使用。注意在计算的中间过程不要使用，只用于最终结果。
不同点就需要注意一下：
  ● toPrecision 是处理精度，精度是从左至右第一个不为0的数开始数起。
  ● toFixed 是小数点后指定位数取整，从小数点开始数起。
两者都能对多余数字做凑整处理，也有些人用 toFixed 来做四舍五入，但一定要知道它是有 Bug 的。
如：1.005.toFixed(2) 返回的是 1.00 而不是 1.01。
原因： 1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去！

### 针对数据
回到最关心的问题：如何解决浮点误差。首先，理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果。
数据展示类
当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下：
parseFloat(1.4000000000000001.toPrecision(12)) === 1.4  // True

封装成方法就是：
function strip(num, precision = 12) {
  return +parseFloat(num.toPrecision(precision));
}
为什么选择 12 做为默认精度？这是一个经验的选择，一般选12就能解决掉大部分0001和0009问题，而且大部分情况下也够用了，如果你需要更精确可以调高。
### 数据运算类
对于运算类操作，如 +-*/，就不能使用 toPrecision 了。正确的做法是把小数转成整数后再运算。以加法为例：
/**
 * 精确加法
 */
function add(num1, num2) {
  const num1Digits = (num1.toString().split('.')[1] || '').length;
  const num2Digits = (num2.toString().split('.')[1] || '').length;
  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
  return (num1 * baseNum + num2 * baseNum) / baseNum;
}
以上方法能适用于大部分场景。遇到科学计数法如 2.3e+1（当数字精度大于21时，数字会强制转为科学计数法形式显示）时还需要特别处理一下。
能读到这里，说明你非常有耐心，那我就放个福利吧。遇到浮点数误差问题时可以直接使用
https://github.com/dt-fe/number-precision
完美支持浮点数的加减乘除、四舍五入等运算。非常小只有1K，远小于绝大多数同类库（如Math.js、BigDecimal.js），100%测试全覆盖，代码可读性强，不妨在你的应用里用起来！