export default class RengarRipple {
    constructor(element) {
        this.element = element || document
        // save all ripple elements
        this.rippleElementList = []
        this.CssClasses = {
            RIPPLE_EFFECT: 'mdl-js-ripple-effect',
            RIPPLE_CONTAINER: 'mdl-ripple-container',
            RIPPLE_ELEMENT: 'mdl-ripple-element',
            IS_ANIMATING: 'is-animating',
            IS_VISIBLE: 'is-visible'
        };
        this.Constant = {
            INITIAL_SCALE: 'scale(0.0001, 0.0001)',
            FINAL_SCALE: ''
        };
    }

    downHandler(index, event) {
        // if not set width and height
        // Calculation width and height firstly
        this.rippleElement = this.rippleElementList[index]
        if (!this.rippleElement.style.width && !this.rippleElement.style.height) {
            const rect = this.targetElement[index].getBoundingClientRect();
            this.boundHeight = rect.height;
            this.boundWidth = rect.width;
            this.rippleSize = Math.sqrt(rect.width * rect.width +
                rect.height * rect.height) * 2 + 2;
            this.rippleElement.style.width = `${this.rippleSize}px`;
            this.rippleElement.style.height = `${this.rippleSize}px`;
        }

        this.rippleElement.classList.add(this.CssClasses.IS_VISIBLE);

        const bound = event.currentTarget.getBoundingClientRect();
        let x;
        let y;
        // Check if we are handling a keyboard click.
        if (event.clientX === 0 && event.clientY === 0) {
            x = Math.round(bound.width / 2);
            y = Math.round(bound.height / 2);
        }
        else {
            const clientX = event.clientX !== undefined ? event.clientX : event.touches[0].clientX;
            const clientY = event.clientY !== undefined ? event.clientY : event.touches[0].clientY;
            x = Math.round(clientX - bound.left);
            y = Math.round(clientY - bound.top);
        }
        this.setRippleXY(x, y);
        this.setRippleStyles(true);
        window.requestAnimationFrame(this.animFrameHandler.bind(this));
    }

    upHandler(event) {
        // Don't fire for the artificial "mouseup" generated by a double-click.
        if (event && event.detail !== 2) {
            // Allow a repaint to occur before removing this class, so the animation
            // shows for tap events, which seem to trigger a mouseup too soon after
            // mousedown.
            window.setTimeout(function remove() {
                this.rippleElement.classList.remove(this.CssClasses.IS_VISIBLE);
            }.bind(this), 0);
        }
    }

    animFrameHandler() {
        this.setRippleStyles(false);
    }

    setRippleXY(newX, newY) {
        this.x = newX;
        this.y = newY;
    }

    setRippleStyles(start) {
        if (this.rippleElement !== null) {
            let scale;
            let offset = `translate(${this.x}px, ${this.y}px)`

            if (start) {
                scale = this.Constant.INITIAL_SCALE;
            }
            else {
                scale = this.Constant.FINAL_SCALE;
                offset = `translate(${this.boundWidth / 2}px, ${this.boundHeight / 2}px)`
            }

            const transformString = `translate(-50%, -50%) ${offset} ${scale}`

            this.rippleElement.style.webkitTransform = transformString;
            this.rippleElement.style.msTransform = transformString;
            this.rippleElement.style.transform = transformString;

            if (start) {
                this.rippleElement.classList.remove(this.CssClasses.IS_ANIMATING);
            }
            else {
                this.rippleElement.classList.add(this.CssClasses.IS_ANIMATING);
            }
        }
    }

    init() {
        if (!this.element) return
        this.targetElement = this.element.querySelectorAll(`.${this.CssClasses.RIPPLE_EFFECT}`)

        Array.prototype.forEach.call(this.targetElement, (el, index) => {
            /**
             * conversion UI:
             * <element class="mdl-js-ripple-effect">
             *     ....
             *     <span class="mdl-ripple-container">
             *         <span class="mdl-ripple-element"></span>
             *     <span>
             * </element>
             */
            const rippleContainer = document.createElement('span')
            rippleContainer.classList.add(this.CssClasses.RIPPLE_CONTAINER)
            const rippleElement = document.createElement('span')
            rippleElement.classList.add(this.CssClasses.RIPPLE_ELEMENT)
            this.rippleElementList.push(rippleElement)
            rippleContainer.appendChild(rippleElement)
            el.appendChild(rippleContainer)

            // binding downHandler and upHandler
            this.boundDownHandler = this.downHandler.bind(this, index)
            this.boundUpHandler = this.upHandler.bind(this)
            el.addEventListener('mousedown', this.boundDownHandler)
            el.addEventListener('touchstart', this.boundDownHandler)
            el.addEventListener('mouseup', this.boundUpHandler)
            el.addEventListener('mouseleave', this.boundUpHandler)
            el.addEventListener('touchend', this.boundUpHandler)
            el.addEventListener('blur', this.boundUpHandler)
        })
    }
}
